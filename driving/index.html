<!DOCTYPE html>
<html>
	<head>
		<title>Driving Simulation</title>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script type="text/javascript" src="node_modules/p2/build/p2.js"></script>
		<style type="text/css">
			html, body {
				margin: 0;
				padding: 0;
			}

			body {
				height: 100%;
				color: white;
				background-color: #121212;
				text-align: center;
			}

			#canvas {
				border: 1px solid white;
			}
		</style>
	</head>
	<body>
		<div style="margin: 20px;">
			<canvas id="canvas"></canvas>
		</div>
		<div id="net" style="font-family: monospace;"></div>
		<script type="text/javascript">
			'use strict';

			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			window.cancelAnimFrame =
				window.cancelAnimationFrame ||
				window.mozCancelAnimationFrame;

			function shuffle(array) { // Fisherâ€“Yates Shuffle
				var m = array.length, t, i;
				while(m) {
					i = Math.floor(Math.random() * m--);
					t = array[m];
					array[m] = array[i];
					array[i] = t;
				}
				return array;
			}

			var inputs = {
				'32': 0,
				'37': 0,
				'38': 0,
				'39': 0,
				'40': 0
			};

			var tickId = false;
			var numInputNodes = 3;
			var numHiddenNodes = 5;
			var numOutputNodes = 3;
			var mutationChance = 0.01;
			var mutationAmount = 0.1;

			var currentIndividual;

			var width = 800;
			var height = 600;
			var canvas = document.getElementById('canvas');
			canvas.width = width;
			canvas.height = height;
			var ctx = canvas.getContext('2d');
		    ctx.scale(1, -1);
		    ctx.translate(0, -height);

			var world = new p2.World({gravity: [0, 0]});
			var wallColGroup = 2;
			var walls = [];

			var Individual = function(p1, p2) {
				if(p1 && p2) {
					for(var i = 0; i < numTriangles; i++) {
						var inherited = [];
						if(Math.random() < 0.5) {
							inherited = p1.data;
						}
						else {
							inherited = p2.data;
						}
						for(var j = 0; j < geneSize; j++) {
							var value = inherited[i * geneSize + j];
							if(Math.random() < mutationChance) {
								value += (Math.random() * 2 - 1) * mutationAmount;
								value = Math.max(0, Math.min(1, value));
							}
							if(isNaN(value)) {
								value = Math.random();
							}
							this.data.push(value);
						}
					}
				}
				else {
					this.inputLayerWeights = [];
					for(var i = 0; i < numInputNodes * numHiddenNodes; i++) {
						this.inputLayerWeights.push(Math.random() - 0.5);
					}
					this.hiddenLayerWeights = [];
					for(var i = 0; i < numHiddenNodes * numOutputNodes; i++) {
						this.hiddenLayerWeights.push(Math.random() - 0.5);
					}
				}

				this.prevFitness = 0;
				this.fitness = 0;
				this.car = new Car(20, 40);
				this.finished = false;
			};

			Individual.prototype.setSimulation = function() {
				world.clear();
				world.gravity = [0, 0];

				addTrack();

				world.addBody(this.car.chassis.body);
				this.car.tdv.addToWorld(world);
				currentIndividual = this;
			};

			Individual.prototype.update = function(dt) {
				this.car.update();

				var inputLayer = this.car.getDistances();
				var hiddenLayer = [0, 0, 0, 0, 0];
				var outputLayer = [0, 0, 0];

				for(var i = 0; i < numHiddenNodes; i++) {
					for(var j = 0; j < numInputNodes; j++) {
						hiddenLayer[i] += inputLayer[j] * this.inputLayerWeights[i * numInputNodes + j];
					}
				}

				for(var i = 0; i < numOutputNodes; i++) {
					for(var j = 0; j < numHiddenNodes; j++) {
						outputLayer[i] += hiddenLayer[j] * this.hiddenLayerWeights[i * numHiddenNodes + j];
					}
				}

				for(var i = 0; i < numOutputNodes; i++) {
					outputLayer[i] = Math.min(Math.max(0, outputLayer[i]), 1);
				}
				var net = "";
				for(var i = 0; i < numInputNodes; i++) {
					net += inputLayer[i].toFixed(2);
					net += ",";
				}
				net += "<br>";
				for(var i = 0; i < numHiddenNodes; i++) {
					net += hiddenLayer[i].toFixed(2);
					net += ",";
				}
				net += "<br>";
				for(var i = 0; i < numOutputNodes; i++) {
					net += outputLayer[i].toFixed(2);
					net += ",";
				}

				this.car.steer = outputLayer[0];
				this.car.throttle = outputLayer[1];
				this.car.brake = outputLayer[2];
				this.prevFitness = this.fitness;
				this.fitness += this.car.speed * dt / 1000;
				document.querySelector('#net').innerHTML = net + '<br>fitness: ' + this.fitness.toFixed(2);
			};

			var Car = function(bodyWidth, bodyHeight) {
				var chassisBody = new p2.Body({position: [400, 300], mass: 1});
				var boxShape = new p2.Box({
					width: bodyWidth,
					height: bodyHeight,
					collisionMask: wallColGroup
				});
				chassisBody.addShape(boxShape);

				var vehicle = new p2.TopDownVehicle(chassisBody);
				var flWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2,  bodyHeight / 2]});
				var frWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2,  bodyHeight / 2]});
				var blWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2, -bodyHeight / 2]});
				var brWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2, -bodyHeight / 2]});
				flWheel.setSideFriction(400);
				frWheel.setSideFriction(400);
				blWheel.setSideFriction(300);
				brWheel.setSideFriction(300);

				flWheel.setBrakeForce(20);
				frWheel.setBrakeForce(20);

				var lSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});
				lSensor.update();
				var fSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});
				var rSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});

				this.tdv = vehicle;
				this.chassis = {
					body: chassisBody,
					box: boxShape
				};
				this.wheels = [flWheel, frWheel, blWheel, brWheel];
				this.lSensor = lSensor;
				this.fSensor = fSensor;
				this.rSensor = rSensor;

				this.speed = 0;
				this.steer = 0.5;
				this.throttle = 0;
				this.brake = 0;
			};

			Car.prototype.getDistances = function() {
				var distances = [1, 1, 1];
				var result = new p2.RaycastResult();
				world.raycast(result, this.lSensor);
				drawRayResult(result, this.lSensor);
				if(result.hasHit()) {
					distances[0] = result.getHitDistance(this.lSensor) / 75;
				}
				result.reset();
				world.raycast(result, this.fSensor);
				drawRayResult(result, this.fSensor);
				if(result.hasHit()) {
					distances[1] = result.getHitDistance(this.fSensor) / 75;
				}
				result.reset();
				world.raycast(result, this.rSensor);
				drawRayResult(result, this.rSensor);
				if(result.hasHit()) {
					distances[2] = result.getHitDistance(this.rSensor) / 75;
				}

				return distances;
			};

			Car.prototype.update = function() {
				this.speed = (this.wheels[2].getSpeed() + this.wheels[3].getSpeed()) / 2;
				var steerValue = 0.63 * -(this.steer * 2 - 1);
				var engineForce = 150 * this.throttle;
				var brakeForce = 150 * this.brake;

				this.wheels[0].steerValue = steerValue;
				this.wheels[1].steerValue = steerValue;

				this.wheels[2].engineForce = engineForce;
				this.wheels[3].engineForce = engineForce;

				this.wheels[2].setBrakeForce(brakeForce);
				this.wheels[3].setBrakeForce(brakeForce);

				var w = this.chassis.box.width;
				var h = this.chassis.box.height;
				var sensorPositions = [];
				sensorPositions.push([-w / 2, h / 2]);
				sensorPositions.push([     0, h / 2]);
				sensorPositions.push([ w / 2, h / 2]);
				sensorPositions.push([-w / 2 - 45, h / 2 + 60]);
				sensorPositions.push([     0     , h / 2 + 75]);
				sensorPositions.push([ w / 2 + 45, h / 2 + 60]);
				for(var i = 0; i < sensorPositions.length; i++) {
					p2.vec2.rotate(sensorPositions[i], sensorPositions[i], this.chassis.body.angle);
					p2.vec2.add(sensorPositions[i], sensorPositions[i], this.chassis.body.position);
				}

				this.lSensor.from = sensorPositions[0];
				this.lSensor.to = sensorPositions[3];
				this.fSensor.from = sensorPositions[1];
				this.fSensor.to = sensorPositions[4];
				this.rSensor.from = sensorPositions[2];
				this.rSensor.to = sensorPositions[5];

				this.lSensor.update();
				this.fSensor.update();
				this.rSensor.update();
			};

			Car.prototype.draw = function() {
				ctx.strokeStyle = 'white';
		        var x = this.chassis.body.position[0];
		        var y = this.chassis.body.position[1];
				var w = this.chassis.box.width;
				var h = this.chassis.box.height;

		        ctx.save();
		        ctx.translate(x, y);
		        ctx.rotate(this.chassis.body.angle);

				ctx.translate(-w / 2, -h / 2);
				ctx.beginPath();
		        ctx.rect(0, 0, w, h);
				ctx.translate(w / 2, h / 2);

				var wheelWidth = w / 6;
				var wheelHeight = h / 6;
				for(var i = 0; i < this.wheels.length; i++) {
					var w = this.wheels[i];
					var x = w.localPosition[0];
					var y = Math.sign(w.localPosition[1]) * (Math.abs(w.localPosition[1]) - wheelHeight);

					ctx.save();
					ctx.translate(x, y);
					if(i < 2) {
						ctx.rotate(0.63 * -(this.steer * 2 - 1));
					}
			        ctx.translate(-wheelWidth / 2, -wheelHeight / 2);

					ctx.rect(0, 0, wheelWidth, wheelHeight);
			        ctx.restore();
				}

				ctx.stroke();
		        ctx.restore();
			};

			function buildTrack() {
				for(var i = 0; i < 10; i++) {
					var wall = new p2.Body({
						position: [width * Math.random(), height * Math.random()],
						angle: 2 * Math.PI * Math.random()
					});
					wall.addShape(new p2.Box({
						width: 100 * Math.random() + 30,
						height: 100 * Math.random() + 30,
						collisionGroup: wallColGroup
					}));
					walls[i] = wall;
				}
			}

			function addTrack() {
				for(var i = 0; i < walls.length; i++) {
					world.addBody(walls[i]);
				}
			}

			function drawWall(wall) {
				ctx.strokeStyle = 'white';
				ctx.beginPath();
				ctx.save();
				ctx.translate(wall.position[0], wall.position[1]);
				ctx.rotate(wall.angle);
				ctx.rect(-wall.shapes[0].width / 2, -wall.shapes[0].height / 2, wall.shapes[0].width, wall.shapes[0].height);
				ctx.stroke();
				ctx.restore();
			}

			function drawRayResult(result, ray){
				ctx.strokeStyle = 'skyblue';
				ctx.beginPath();
				ctx.moveTo(ray.from[0], ray.from[1]);
				ctx.lineTo(ray.to[0], ray.to[1]);
				ctx.stroke();

				ctx.strokeStyle = 'yellow';
				var hitPoint = p2.vec2.create();
				result.getHitPoint(hitPoint, ray);

				if(result.hasHit()) {
					ctx.beginPath();
					ctx.arc(hitPoint[0], hitPoint[1], 5, 0, 2 * Math.PI);
					ctx.stroke();
				}

				ctx.beginPath();
				ctx.moveTo(hitPoint[0], hitPoint[1]);
				ctx.lineTo(hitPoint[0] + result.normal[0] * 10, hitPoint[1] + result.normal[1] * 10);
				ctx.stroke();
			}

			var lastTime;
			function tick(time) {
				var dt = lastTime ? time - lastTime : 0;
				world.step(1 / 60, dt / 1000, 10);
				ctx.clearRect(0, 0, width, height);

				for(var i = 0; i < walls.length; i++) {
					drawWall(walls[i]);
				}

				if(currentIndividual) {
					currentIndividual.update(dt);
					currentIndividual.car.draw();
				}

				lastTime = time;
				tickId = requestAnimFrame(tick);
			}

			function iterate() {
				var datalen = data.length;

				data = data.sort(function(a, b) {
					return b.fitness - a.fitness;
				});

				data[0].draw(ctx, canvas.width / width);
				mutationAmount = 0.1 / Math.pow(data[0].fitness, 2);

				var breeders = data.slice(0, Math.max(2, ~~(datalen * 0.15)));
				data = [];
				for(var i = data.length; i < datalen; i++) {
					breeders = shuffle(breeders);
					data.push(new Individual(breeders[0], breeders[1]));
				}

				tickId = requestAnimFrame(iterate);
			}

			function start() {
				if(!tickId) {
					iterate();
				}
			}

			function reset() {
				cancelAnimFrame(tickId);
				tickId = false;

				data = [];
				for(var i = 0; i < 20; i++) {
					data.push(new Individual());
				}
			}

			buildTrack();
			tick();
		</script>
	</body>
</html>
