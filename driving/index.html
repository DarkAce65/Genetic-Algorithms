<!DOCTYPE html>
<html>
	<head>
		<title>Driving Simulation</title>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script type="text/javascript" src="node_modules/matter-js/build/matter.min.js"></script>
		<style type="text/css">
			html, body {
				margin: 0;
				padding: 0;
			}

			body {
				height: 100%;
				color: white;
				background-color: #121212;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div style="margin: 20px;">
			<canvas id="canvas"></canvas>
		</div>
		<script type="text/javascript">
			'use strict';

			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			window.cancelAnimFrame =
				window.cancelAnimationFrame ||
				window.mozCancelAnimationFrame;

			function shuffle(array) { // Fisherâ€“Yates Shuffle
				var m = array.length, t, i;
				while(m) {
					i = Math.floor(Math.random() * m--);
					t = array[m];
					array[m] = array[i];
					array[i] = t;
				}
				return array;
			}

			var tickId = false;
			var numHiddenNodes = 5;
			var mutationChance = 0.01;
			var mutationAmount = 0.1;
			var width = 800;
			var height = 600;
			var canvas = document.getElementById('canvas');
			canvas.width = width;
			canvas.height = height;
			var ctx = canvas.getContext('2d');

			var engine = Matter.Engine.create();
			engine.world.gravity.y = 0;
			var render = Matter.Render.create({
				canvas: canvas,
				engine: engine,
				options: {
					showPositions: true,
					showVelocity: true,
					showAngleIndicator: true
				}
			});

			var data = [];
			var imageData = [];

			var Individual = function(p1, p2) {
				this.data = [];

				if(p1 && p2) {
					for(var i = 0; i < numTriangles; i++) {
						var inherited = [];
						if(Math.random() < 0.5) {
							inherited = p1.data;
						}
						else {
							inherited = p2.data;
						}
						for(var j = 0; j < geneSize; j++) {
							var value = inherited[i * geneSize + j];
							if(Math.random() < mutationChance) {
								value += (Math.random() * 2 - 1) * mutationAmount;
								value = Math.max(0, Math.min(1, value));
							}
							if(isNaN(value)) {
								value = Math.random();
							}
							this.data.push(value);
						}
					}
				}
				else {
					this.inputLayerWeights = [];
					for(var i = 0; i < numHiddenNodes * 3; i++) {
						this.inputLayerWeights[i] = Math.random();
					}
					this.hiddenLayer = [];
					for(var i = 0; i < numHiddenNodes * 2; i++) {
						this.hiddenLayer[i] = Math.random();
					}
				}

				this.fitness = 0;
				resetSimulation();
				// this.fitness = this.calculateFitness();
			};

			function resetSimulation() {
				Matter.World.clear(engine.world);
				Matter.Engine.clear(engine);

				var boxA = Matter.Bodies.rectangle(400, 200, 80, 80);
				var boxB = Matter.Bodies.rectangle(450, 50, 80, 80);
				var edges = [];
				edges.push(Matter.Bodies.rectangle(-10, 300, 20, 640, {isStatic: true}));
				edges.push(Matter.Bodies.rectangle(400, -10, 840, 20, {isStatic: true}));
				edges.push(Matter.Bodies.rectangle(810, 300, 20, 640, {isStatic: true}));
				edges.push(Matter.Bodies.rectangle(400, 610, 840, 20, {isStatic: true}));

				Matter.World.add(engine.world, [boxA, boxB]);
				Matter.World.add(engine.world, edges);
			};

			function tick(time) {
				Matter.Engine.update(engine, 1000 / 60);
				Matter.Render.world(render);

				tickId = requestAnimFrame(tick);
			};

			function iterate() {
				var datalen = data.length;

				data = data.sort(function(a, b) {
					return b.fitness - a.fitness;
				});

				data[0].draw(ctx, canvas.width / width);
				mutationAmount = 0.1 / Math.pow(data[0].fitness, 2);

				var breeders = data.slice(0, Math.max(2, ~~(datalen * 0.15)));
				data = [];
				for(var i = data.length; i < datalen; i++) {
					breeders = shuffle(breeders);
					data.push(new Individual(breeders[0], breeders[1]));
				}

				tickId = requestAnimFrame(iterate);
			}

			function start() {
				if(!tickId) {
					iterate();
				}
			}

			function reset() {
				cancelAnimFrame(tickId);
				tickId = false;

				data = [];
				for(var i = 0; i < 20; i++) {
					data.push(new Individual());
				}
			}

			var a = new Individual();
			tick();
		</script>
	</body>
</html>
