<!DOCTYPE html>
<html>
	<head>
		<title>Driving Simulation</title>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script type="text/javascript" src="node_modules/p2/build/p2.js"></script>
		<style type="text/css">
			html, body {
				margin: 0;
				padding: 0;
			}

			body {
				height: 100%;
				color: white;
				background-color: #121212;
				text-align: center;
			}

			button {
				background-color: #121212;
				color: whitesmoke;
				border: 2px solid whitesmoke;
				border-radius: 0;
				padding: 7px 14px;
				margin-left: -2px;
				font-weight: bold;
				cursor: pointer;
			}

			button:hover, button:focus {
				outline: none;
				background-color: #333333;
			}

			button:first-child {
				margin-left: 0;
				border-top-left-radius: 4px;
				border-bottom-left-radius: 4px;
			}

			button:last-child {
				border-top-right-radius: 4px;
				border-bottom-right-radius: 4px;
			}

			#canvas {
				border: 1px solid white;
			}

			#genetic, #net {
				font-family: monospace;
			}
		</style>
	</head>
	<body>
		<div style="margin: 20px;">
			<canvas id="canvas"></canvas>
			<div id="net">speed: 0.00, fitness: 0.00, best fitness: 0.00</div>
			<div id="genetic">Generation: 0, Genome: 0</div>
		</div>
		<div><button onclick="start();">Start</button><button onclick="kill();">Kill Current Simulation</button><button onclick="reset();">Reset</button></div>
		<script type="text/javascript">
			'use strict';

			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			window.cancelAnimFrame =
				window.cancelAnimationFrame ||
				window.mozCancelAnimationFrame;

			function shuffle(array) { // Fisherâ€“Yates Shuffle
				var m = array.length, t, i;
				while(m) {
					i = Math.floor(Math.random() * m--);
					t = array[m];
					array[m] = array[i];
					array[i] = t;
				}
				return array;
			}

			var inputs = {
				'32': 0,
				'37': 0,
				'38': 0,
				'39': 0,
				'40': 0
			};

			var tickId = false;
			var numInputNodes = 3;
			var numHiddenNodes = 5;
			var numOutputNodes = 3;
			var mutationChance = 0.1;
			var mutationAmount = 0.1;
			var speedAvgWindow = 50;

			var data = [];
			var trails = [];
			var generation = 0;
			var genome = 0;
			var currentIndividual;
			var bestFitness = 0;

			var width = 800;
			var height = 600;
			var canvas = document.getElementById('canvas');
			canvas.width = width;
			canvas.height = height;
			var ctx = canvas.getContext('2d');
		    ctx.scale(1, -1);
		    ctx.translate(0, -height);

			var world = new p2.World({gravity: [0, 0]});
			var wallColGroup = 2;
			var walls = [];
			var startingPosition = [width / 2, height / 2];
			var startingAngle = 0;

			var Individual = function(p1, p2) {
				this.inputLayerWeights = [];
				this.hiddenLayerWeights = [];

				if(p1 && p2) {
					for(var i = 0; i < numInputNodes * numHiddenNodes; i++) {
						if(Math.random() < 0.5) {
							this.inputLayerWeights.push(p1.inputLayerWeights[i]);
						}
						else {
							this.inputLayerWeights.push(p2.inputLayerWeights[i]);
						}

						if(Math.random() < mutationChance) {
							var v = this.inputLayerWeights[i];
							v += (Math.random() * 2 - 1) * mutationAmount;
							v = Math.max(-1, Math.min(1, v));
							this.inputLayerWeights[i] = v;
						}
					}
					for(var i = 0; i < numHiddenNodes * numOutputNodes; i++) {
						if(Math.random() < 0.5) {
							this.hiddenLayerWeights.push(p1.hiddenLayerWeights[i]);
						}
						else {
							this.hiddenLayerWeights.push(p2.hiddenLayerWeights[i]);
						}

						if(Math.random() < mutationChance) {
							var v = this.inputLayerWeights[i];
							v += (Math.random() * 2 - 1) * mutationAmount;
							v = Math.max(-1, Math.min(1, v));
							this.inputLayerWeights[i] = v;
						}
					}
				}
				else {
					for(var i = 0; i < numInputNodes * numHiddenNodes; i++) {
						this.inputLayerWeights.push(Math.random() * 2 - 1);
					}
					for(var i = 0; i < numHiddenNodes * numOutputNodes; i++) {
						this.hiddenLayerWeights.push(Math.random() * 2 - 1);
					}
				}

				this.prevFitness = 0;
				this.fitness = 0;
				this.finished = false;
				this.car = new Car(20, 40);
			};

			Individual.prototype.setSimulation = function() {
				world.clear();
				world.gravity = [0, 0];

				world.on('beginContact', function(event) {
					currentIndividual.finished = true;
				});

				addTrack();

				this.prevFitness = 0;
				this.fitness = 0;
				this.finished = false;

				this.car = new Car(20, 40);
				trails.push([p2.vec2.clone(this.car.chassis.body.position)]);
				world.addBody(this.car.chassis.body);
				this.car.tdv.addToWorld(world);

				currentIndividual = this;
			};

			Individual.prototype.update = function() {
				this.car.update();
				bestFitness = Math.max(bestFitness, this.fitness);

				if(this.car.speeds.length == speedAvgWindow && this.car.avgSpeed < 1) {
					this.finished = true;
				}

				var inputLayer = this.car.getDistances();
				var hiddenLayer = [0, 0, 0, 0, 0];
				var outputLayer = [0, 0, 0];

				for(var i = 0; i < numHiddenNodes; i++) {
					for(var j = 0; j < numInputNodes; j++) {
						hiddenLayer[i] += inputLayer[j] * this.inputLayerWeights[i * numInputNodes + j];
					}
				}

				for(var i = 0; i < numOutputNodes; i++) {
					for(var j = 0; j < numHiddenNodes; j++) {
						outputLayer[i] += hiddenLayer[j] * this.hiddenLayerWeights[i * numHiddenNodes + j];
					}
				}

				for(var i = 0; i < numOutputNodes; i++) {
					outputLayer[i] = Math.min(Math.max(0, outputLayer[i]), 1);
				}

				this.car.steer = outputLayer[0];
				this.car.throttle = outputLayer[1];
				this.car.brake = outputLayer[2];
				this.prevFitness = this.fitness;
				var speed = this.car.speeds[this.car.speeds.length - 1];
				this.fitness += speed / 1000;
				trails[genome].push(p2.vec2.clone(this.car.chassis.body.position));
				document.querySelector('#net').innerHTML = 'speed: ' + speed.toFixed(2) + ', fitness: ' + this.fitness.toFixed(2) + ', best fitness: ' + bestFitness.toFixed(2);
			};

			var Car = function(bodyWidth, bodyHeight) {
				var chassisBody = new p2.Body({
					mass: 1,
					position: p2.vec2.clone(startingPosition),
					angle: startingAngle
				});
				var boxShape = new p2.Box({
					width: bodyWidth,
					height: bodyHeight,
					collisionMask: wallColGroup
				});
				chassisBody.addShape(boxShape);

				var vehicle = new p2.TopDownVehicle(chassisBody);
				var flWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2,  bodyHeight / 2]});
				var frWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2,  bodyHeight / 2]});
				var blWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2, -bodyHeight / 2]});
				var brWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2, -bodyHeight / 2]});
				flWheel.setSideFriction(400);
				frWheel.setSideFriction(400);
				blWheel.setSideFriction(300);
				brWheel.setSideFriction(300);

				flWheel.setBrakeForce(20);
				frWheel.setBrakeForce(20);

				var lSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});
				var fSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});
				var rSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});

				this.tdv = vehicle;
				this.chassis = {
					body: chassisBody,
					box: boxShape
				};
				this.wheels = [flWheel, frWheel, blWheel, brWheel];
				this.lSensor = lSensor;
				this.fSensor = fSensor;
				this.rSensor = rSensor;

				this.speeds = [];
				this.avgSpeed = 0;
				this.steer = 0.5;
				this.throttle = 0;
				this.brake = 0;
			};

			Car.prototype.getDistances = function() {
				var distances = [1, 1, 1];
				var result = new p2.RaycastResult();
				world.raycast(result, this.lSensor);
				drawSensor(result, this.lSensor);
				if(result.hasHit()) {
					distances[0] = result.getHitDistance(this.lSensor) / 75;
				}
				result.reset();
				world.raycast(result, this.fSensor);
				drawSensor(result, this.fSensor);
				if(result.hasHit()) {
					distances[1] = result.getHitDistance(this.fSensor) / 75;
				}
				result.reset();
				world.raycast(result, this.rSensor);
				drawSensor(result, this.rSensor);
				if(result.hasHit()) {
					distances[2] = result.getHitDistance(this.rSensor) / 75;
				}

				return distances;
			};

			Car.prototype.update = function() {
				this.speeds.push((this.wheels[2].getSpeed() + this.wheels[3].getSpeed()) / 2);
				if(this.speeds.length > speedAvgWindow) {
					this.speeds.shift();
				}

				var sum = 0;
				for(var i = 0; i < this.speeds.length; i++) {
					sum += this.speeds[i];
				}
				this.avgSpeed = sum / this.speeds.length;

				var steerValue = 0.63 * -(this.steer * 2 - 1);
				var engineForce = 150 * this.throttle;
				var brakeForce = 150 * this.brake;

				this.wheels[0].steerValue = steerValue;
				this.wheels[1].steerValue = steerValue;

				this.wheels[2].engineForce = engineForce;
				this.wheels[3].engineForce = engineForce;

				this.wheels[2].setBrakeForce(brakeForce);
				this.wheels[3].setBrakeForce(brakeForce);

				var w = this.chassis.box.width * 9 / 10;
				var h = this.chassis.box.height * 9 / 10;
				var sensorPositions = [];
				sensorPositions.push([-w / 2, h / 2]);
				sensorPositions.push([     0, h / 2]);
				sensorPositions.push([ w / 2, h / 2]);
				sensorPositions.push([-w / 2 - 45, h / 2 + 60]);
				sensorPositions.push([     0     , h / 2 + 75]);
				sensorPositions.push([ w / 2 + 45, h / 2 + 60]);
				for(var i = 0; i < sensorPositions.length; i++) {
					p2.vec2.rotate(sensorPositions[i], sensorPositions[i], this.chassis.body.angle);
					p2.vec2.add(sensorPositions[i], sensorPositions[i], this.chassis.body.position);
				}

				this.lSensor.from = sensorPositions[0];
				this.lSensor.to = sensorPositions[3];
				this.fSensor.from = sensorPositions[1];
				this.fSensor.to = sensorPositions[4];
				this.rSensor.from = sensorPositions[2];
				this.rSensor.to = sensorPositions[5];

				this.lSensor.update();
				this.fSensor.update();
				this.rSensor.update();
			};

			Car.prototype.draw = function() {
				ctx.strokeStyle = 'white';
		        var x = this.chassis.body.position[0];
		        var y = this.chassis.body.position[1];
				var w = this.chassis.box.width;
				var h = this.chassis.box.height;

		        ctx.save();
		        ctx.translate(x, y);
		        ctx.rotate(this.chassis.body.angle);

				ctx.translate(-w / 2, -h / 2);
				ctx.beginPath();
				ctx.rect(0, 0, w, h);
				ctx.translate(w / 2, h / 2);

				var wheelWidth = w / 6;
				var wheelHeight = h / 6;
				for(var i = 0; i < this.wheels.length; i++) {
					var w = this.wheels[i];
					var x = w.localPosition[0];
					var y = Math.sign(w.localPosition[1]) * (Math.abs(w.localPosition[1]) - wheelHeight);

					ctx.save();
					ctx.translate(x, y);
					if(i < 2) {
						ctx.rotate(0.63 * -(this.steer * 2 - 1));
					}
			        ctx.translate(-wheelWidth / 2, -wheelHeight / 2);

					ctx.rect(0, 0, wheelWidth, wheelHeight);
			        ctx.restore();
				}

				ctx.stroke();
		        ctx.restore();
			};

			function buildWall(pt0, pt1) {
				var wall = new p2.Body({
					position: [(pt0[0] + pt1[0]) / 2, (pt0[1] + pt1[1]) / 2],
					angle: Math.atan2(pt1[1] - pt0[1], pt1[0] - pt0[0])
				});
				wall.addShape(new p2.Box({
					width: p2.vec2.dist(pt0, pt1),
					height: 5,
					collisionGroup: wallColGroup
				}));

				return wall;
			}

			function buildTrack(points) {
				walls = [];
				if(points && points.length > 1) {
					var pathWidth = 80;

					points.push(points[0]);
					points.push(points[1]);

					var innerPoints = [];
					var outerPoints = [];

					var x = points[0][0];
					var y = points[0][1];
					var x1 = points[1][0];
					var y1 = points[1][1];
					var prevAngle = Math.atan2(y1 - y, x1 - x);
					startingPosition = points[0];
					startingAngle = prevAngle - Math.PI / 2;

					for(var i = 0; i < points.length - 1; i++) {
						var x = points[i][0];
						var y = points[i][1];
						var x1 = points[i + 1][0];
						var y1 = points[i + 1][1];

						var angle = Math.atan2(y1 - y, x1 - x);
						var pathAngle = Math.PI + angle - prevAngle;

						var shift = [Math.cos(pathAngle / 2 + prevAngle), Math.sin(pathAngle / 2 + prevAngle)];
						p2.vec2.scale(shift, shift, (pathWidth + 5) / 2 / Math.sin(pathAngle / 2));

						var inPt = p2.vec2.add([0, 0], points[i], shift);
						var outPt = p2.vec2.sub([0, 0], points[i], shift);

						innerPoints.push(inPt);
						outerPoints.push(outPt);

						if(i === points.length - 2) {
							innerPoints[0] = inPt;
							outerPoints[0] = outPt;
						}

						prevAngle = angle;
					}

					for(var i = 0; i < innerPoints.length - 1; i++) {
						walls.push(buildWall(innerPoints[i], innerPoints[i + 1]));
					}
					for(var i = 0; i < outerPoints.length - 1; i++) {
						walls.push(buildWall(outerPoints[i], outerPoints[i + 1]));
					}
				}
				else {
					startingPosition = [width / 2, height / 2];
					startingAngle = 0;
					for(var i = 0; i < 20; i++) {
						var wall = new p2.Body({
							position: [width * Math.random(), height * Math.random()],
							angle: 2 * Math.PI * Math.random()
						});
						wall.addShape(new p2.Box({
							width: 80 * Math.random() + 30,
							height: 80 * Math.random() + 30,
							collisionGroup: wallColGroup
						}));
						walls[i] = wall;
					}
				}

				var top = new p2.Body({position: [width / 2, 0]});
				top.addShape(new p2.Box({
					width: width,
					height: 10,
					collisionGroup: wallColGroup
				}));
				walls.push(top);
				var bottom = new p2.Body({position: [width / 2, height]});
				bottom.addShape(new p2.Box({
					width: width,
					height: 10,
					collisionGroup: wallColGroup
				}));
				walls.push(bottom);
				var left = new p2.Body({position: [0, height / 2]});
				left.addShape(new p2.Box({
					width: 10,
					height: height,
					collisionGroup: wallColGroup
				}));
				walls.push(left);
				var right = new p2.Body({position: [width, height / 2]});
				right.addShape(new p2.Box({
					width: 10,
					height: height,
					collisionGroup: wallColGroup
				}));
				walls.push(right);
			}

			function addTrack() {
				for(var i = 0; i < walls.length; i++) {
					world.addBody(walls[i]);
				}
			}

			function drawWall(wall) {
				ctx.strokeStyle = 'white';
				ctx.beginPath();
				ctx.save();
				ctx.translate(wall.position[0], wall.position[1]);
				ctx.rotate(wall.angle);
				ctx.clearRect(-wall.shapes[0].width / 2, -wall.shapes[0].height / 2, wall.shapes[0].width, wall.shapes[0].height);
				ctx.rect(-wall.shapes[0].width / 2, -wall.shapes[0].height / 2, wall.shapes[0].width, wall.shapes[0].height);
				ctx.stroke();
				ctx.restore();
			}

			function drawSensor(result, ray) {
				ctx.strokeStyle = '#ff5050';
				ctx.beginPath();
				ctx.moveTo(ray.from[0], ray.from[1]);
				ctx.lineTo(ray.to[0], ray.to[1]);
				ctx.stroke();

				var hitPoint = p2.vec2.create();
				result.getHitPoint(hitPoint, ray);

				if(result.hasHit()) {
					ctx.beginPath();
					ctx.arc(hitPoint[0], hitPoint[1], 5, 0, 2 * Math.PI);
					ctx.stroke();
				}

				ctx.beginPath();
				ctx.moveTo(hitPoint[0], hitPoint[1]);
				ctx.lineTo(hitPoint[0] + result.normal[0] * 10, hitPoint[1] + result.normal[1] * 10);
				ctx.stroke();
			}

			function makeNewPopulation() {
				trails = [];
				genome = 0;
				if(generation == 0) {
					data = [];
					for(var i = 0; i < 20; i++) {
						data.push(new Individual());
					}
				}
				else {
					var datalen = data.length;
					data = data.sort(function(a, b) {
						return b.fitness - a.fitness;
					});

					var breeders = data.slice(0, Math.max(2, ~~(datalen * 0.15)));
					data = [breeders[0]];
					for(var i = data.length; i < datalen - 1; i++) {
						breeders = shuffle(breeders);
						data.push(new Individual(breeders[0], breeders[1]));
					}
					data.push(new Individual());
				}
			}

			function tick(time) {
				world.step(1 / 60);
				ctx.clearRect(0, 0, width, height);

				for(var i = 0; i < walls.length; i++) {
					drawWall(walls[i]);
				}

				for(var i = 0; i < trails.length; i++) {
					ctx.strokeStyle = i === trails.length - 1 ? 'lightblue' : '#444444';
					ctx.beginPath();
					ctx.moveTo(trails[i][0][0], trails[i][0][1]);
					for(var j = 1; j < trails[i].length; j++) {
						ctx.lineTo(trails[i][j][0], trails[i][j][1]);
					}
					ctx.stroke();
				}

				if(currentIndividual) {
					currentIndividual.update();
					currentIndividual.car.draw();

					if(currentIndividual.finished) {
						genome++;
						if(genome >= data.length) {
							generation++;
							makeNewPopulation();
						}

						currentIndividual = data[genome];
						currentIndividual.setSimulation();
						document.querySelector('#genetic').innerHTML = 'Generation: ' + generation + ', Genome: ' + genome;
					}
				}

				tickId = requestAnimFrame(tick);
			}

			function start() {
				if(!tickId) {
					data[0].setSimulation();
					document.querySelector('#genetic').innerHTML = 'Generation: ' + generation + ', Genome: ' + genome;
					tick();
				}
			}

			function kill() {
				if(currentIndividual) {
					currentIndividual.finished = true;
				}
			}

			function reset() {
				var track = [[160, 230], [85, 330], [335, 520], [660, 440], [710, 380], [680, 330], [510, 350], [370, 330], [390, 240], [590, 200], [690, 155], [670, 80], [510, 60], [150, 100]];
				buildTrack(track);

				cancelAnimFrame(tickId);
				tickId = false;

				ctx.clearRect(0, 0, width, height);

				for(var i = 0; i < walls.length; i++) {
					drawWall(walls[i]);
				}

				currentIndividual = undefined;
				bestFitness = 0;
				generation = 0;
				genome = 0;
				makeNewPopulation();
				document.querySelector('#genetic').innerHTML = 'Generation: ' + generation + ', Genome: ' + genome;
				document.querySelector('#net').innerHTML = 'speed: 0.00, fitness: 0.00, best fitness: 0.00';
			}

			reset();
		</script>
	</body>
</html>
