<!DOCTYPE html>
<html>
	<head>
		<title>Driving Simulation</title>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script type="text/javascript" src="node_modules/p2/build/p2.js"></script>
		<style type="text/css">
			html, body {
				margin: 0;
				padding: 0;
			}

			body {
				height: 100%;
				color: white;
				background-color: #121212;
				text-align: center;
			}

			#canvas {
				border: 1px solid white;
			}
		</style>
	</head>
	<body>
		<div style="margin: 20px;">
			<canvas id="canvas"></canvas>
		</div>
		<div id="net" style="font-family: monospace;"></div>
		<script type="text/javascript">
			'use strict';

			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			window.cancelAnimFrame =
				window.cancelAnimationFrame ||
				window.mozCancelAnimationFrame;

			function shuffle(array) { // Fisherâ€“Yates Shuffle
				var m = array.length, t, i;
				while(m) {
					i = Math.floor(Math.random() * m--);
					t = array[m];
					array[m] = array[i];
					array[i] = t;
				}
				return array;
			}

			var inputs = {
				'32': 0,
				'37': 0,
				'38': 0,
				'39': 0,
				'40': 0
			};

			var numInputNodes = 3;
			var numHiddenNodes = 5;
			var numOutputNodes = 3;
			var tickId = false;
			var mutationChance = 0.01;
			var mutationAmount = 0.1;
			var currentIndividual;
			var width = 800;
			var height = 600;
			var canvas = document.getElementById('canvas');
			canvas.width = width;
			canvas.height = height;
			var ctx = canvas.getContext('2d');
		    ctx.scale(1, -1);
		    ctx.translate(0, -height);

			var world = new p2.World({gravity: [0, 0]});

			var data = [];
			var imageData = [];

			var Individual = function(p1, p2) {
				if(p1 && p2) {
					for(var i = 0; i < numTriangles; i++) {
						var inherited = [];
						if(Math.random() < 0.5) {
							inherited = p1.data;
						}
						else {
							inherited = p2.data;
						}
						for(var j = 0; j < geneSize; j++) {
							var value = inherited[i * geneSize + j];
							if(Math.random() < mutationChance) {
								value += (Math.random() * 2 - 1) * mutationAmount;
								value = Math.max(0, Math.min(1, value));
							}
							if(isNaN(value)) {
								value = Math.random();
							}
							this.data.push(value);
						}
					}
				}
				else {
					this.inputLayerWeights = [];
					for(var i = 0; i < numInputNodes * numHiddenNodes; i++) {
						this.inputLayerWeights.push(Math.random());
					}
					this.hiddenLayerWeights = [];
					for(var i = 0; i < numHiddenNodes * numOutputNodes; i++) {
						this.hiddenLayerWeights.push(Math.random());
					}
				}

				this.fitness = 0;
				this.car = new Car(20, 40);
			};

			Individual.prototype.update = function() {
				this.car.update();

				var inputLayer = [0, 0, 0];
				var hiddenLayer = [0, 0, 0, 0, 0];
				var outputLayer = [0, 0, 0];

				for(var i = 0; i < numHiddenNodes; i++) {
					for(var j = 0; j < numInputNodes; j++) {
						hiddenLayer[i] += inputLayer[j] * this.inputLayerWeights[i * numInputNodes + j];
					}
				}

				for(var i = 0; i < numOutputNodes; i++) {
					for(var j = 0; j < numHiddenNodes; j++) {
						outputLayer[i] += hiddenLayer[j] * this.hiddenLayerWeights[i * numHiddenNodes + j];
					}
				}
				var net = "";
				for(var i = 0; i < numInputNodes; i++) {
					net += inputLayer[i].toFixed(2);
					net += ",";
				}
				net += "<br>";
				for(var i = 0; i < numHiddenNodes; i++) {
					net += hiddenLayer[i].toFixed(2);
					net += ",";
				}
				net += "<br>";
				for(var i = 0; i < numOutputNodes; i++) {
					net += outputLayer[i].toFixed(2);
					net += ",";
				}
				document.querySelector('#net').innerHTML = net;

				this.car.steer = outputLayer[0] * 2 - 1;
				this.car.throttle = outputLayer[1];
				this.car.brake = outputLayer[2];
			};

			var Car = function(bodyWidth, bodyHeight) {
				var chassisBody = new p2.Body({position: [400, 300], mass: 1});
				var boxShape = new p2.Box({width: bodyWidth, height: bodyHeight});
				chassisBody.addShape(boxShape);

				var vehicle = new p2.TopDownVehicle(chassisBody);
				var flWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2,  bodyHeight / 2]});
				var frWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2,  bodyHeight / 2]});
				var blWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2, -bodyHeight / 2]});
				var brWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2, -bodyHeight / 2]});
				flWheel.setSideFriction(400);
				frWheel.setSideFriction(400);
				blWheel.setSideFriction(300);
				brWheel.setSideFriction(300);

				flWheel.setBrakeForce(20);
				frWheel.setBrakeForce(20);

				this.tdv = vehicle;
				this.chassis = {
					body: chassisBody,
					box: boxShape
				};
				this.wheels = [flWheel, frWheel, blWheel, brWheel];
				this.speed = 0;
				this.steer = 0;
				this.throttle = 0;
				this.brake = 0;
			};

			Car.prototype.update = function() {
				this.speed = (this.wheels[2].getSpeed() + this.wheels[3].getSpeed()) / 2;
				var steerValue = 0.63 * -this.steer;
				var engineForce = 150 * this.throttle;
				var brakeForce = 150 * this.brake;

				this.wheels[0].steerValue = steerValue;
				this.wheels[1].steerValue = steerValue;

				this.wheels[2].engineForce = engineForce;
				this.wheels[3].engineForce = engineForce;

				this.wheels[2].setBrakeForce(brakeForce);
				this.wheels[3].setBrakeForce(brakeForce);
			};

			Car.prototype.draw = function() {
				ctx.strokeStyle = 'white';
		        var x = this.chassis.body.position[0];
		        var y = this.chassis.body.position[1];
				var w = this.chassis.box.width;
				var h = this.chassis.box.height;

		        ctx.save();
		        ctx.translate(x, y);
		        ctx.rotate(this.chassis.body.angle);

				ctx.translate(-w / 2, -h / 2);
				ctx.beginPath();
		        ctx.rect(0, 0, w, h);
				ctx.translate(w / 2, h / 2);

				var wheelWidth = w / 6;
				var wheelHeight = h / 6;
				for(var i = 0; i < this.wheels.length; i++) {
					var w = this.wheels[i];
					var x = w.localPosition[0];
					var y = Math.sign(w.localPosition[1]) * (Math.abs(w.localPosition[1]) - wheelHeight);

					ctx.save();
					ctx.translate(x, y);
					if(i < 2) {
						ctx.rotate(0.63 * -this.steer);
					}
			        ctx.translate(-wheelWidth / 2, -wheelHeight / 2);

					ctx.rect(0, 0, wheelWidth, wheelHeight);
			        ctx.restore();
				}

				ctx.stroke();
		        ctx.restore();
			};

			function resetSimulation(individual) {
				world.clear();
				world.gravity = [0, 0];

				if(individual) {
					world.addBody(individual.car.chassis.body);
					individual.car.tdv.addToWorld(world);
				}
			};

			var lastTime;
			function tick(time) {
				var dt = lastTime ? (time - lastTime) / 1000 : 0;
				world.step(1 / 60, dt, 10);
				ctx.clearRect(0, 0, width, height);
				currentIndividual.update();
				currentIndividual.car.draw();

				lastTime = time;
				tickId = requestAnimFrame(tick);
			};

			function iterate() {
				var datalen = data.length;

				data = data.sort(function(a, b) {
					return b.fitness - a.fitness;
				});

				data[0].draw(ctx, canvas.width / width);
				mutationAmount = 0.1 / Math.pow(data[0].fitness, 2);

				var breeders = data.slice(0, Math.max(2, ~~(datalen * 0.15)));
				data = [];
				for(var i = data.length; i < datalen; i++) {
					breeders = shuffle(breeders);
					data.push(new Individual(breeders[0], breeders[1]));
				}

				tickId = requestAnimFrame(iterate);
			}

			function start() {
				if(!tickId) {
					iterate();
				}
			}

			function reset() {
				cancelAnimFrame(tickId);
				tickId = false;

				data = [];
				for(var i = 0; i < 20; i++) {
					data.push(new Individual());
				}
			}

			currentIndividual = new Individual();
			resetSimulation(currentIndividual);
			tick();
		</script>
	</body>
</html>
