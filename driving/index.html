<!DOCTYPE html>
<html>
	<head>
		<title>Driving Simulation</title>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script type="text/javascript" src="node_modules/matter-js/build/matter.min.js"></script>
		<style type="text/css">
			html, body {
				margin: 0;
				padding: 0;
			}

			body {
				height: 100%;
				color: white;
				background-color: #121212;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div style="margin: 20px;">
			<canvas id="canvas"></canvas>
		</div>
		<div id="car"></div>
		<div id="inputs"></div>
		<script type="text/javascript">
			'use strict';

			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			window.cancelAnimFrame =
				window.cancelAnimationFrame ||
				window.mozCancelAnimationFrame;

			function shuffle(array) { // Fisherâ€“Yates Shuffle
				var m = array.length, t, i;
				while(m) {
					i = Math.floor(Math.random() * m--);
					t = array[m];
					array[m] = array[i];
					array[i] = t;
				}
				return array;
			}

			var inputs = {};
			var tickId = false;
			var numHiddenNodes = 5;
			var mutationChance = 0.01;
			var mutationAmount = 0.1;
			var width = 800;
			var height = 600;
			var canvas = document.getElementById('canvas');
			canvas.width = width;
			canvas.height = height;
			var ctx = canvas.getContext('2d');

			var engine = Matter.Engine.create();
			engine.world.gravity.y = 0;
			var render = Matter.Render.create({
				canvas: canvas,
				engine: engine,
				options: {
					showAngleIndicator: true,
					showBounds: true,
					showCollisions: true,
					showConvexHulls: true,
					showSeparations: true,
					showVelocity: true
				}
			});

			var data = [];
			var imageData = [];

			var Individual = function(p1, p2) {
				this.data = [];

				if(p1 && p2) {
					for(var i = 0; i < numTriangles; i++) {
						var inherited = [];
						if(Math.random() < 0.5) {
							inherited = p1.data;
						}
						else {
							inherited = p2.data;
						}
						for(var j = 0; j < geneSize; j++) {
							var value = inherited[i * geneSize + j];
							if(Math.random() < mutationChance) {
								value += (Math.random() * 2 - 1) * mutationAmount;
								value = Math.max(0, Math.min(1, value));
							}
							if(isNaN(value)) {
								value = Math.random();
							}
							this.data.push(value);
						}
					}
				}
				else {
					this.inputLayerWeights = [];
					for(var i = 0; i < numHiddenNodes * 3; i++) {
						this.inputLayerWeights[i] = Math.random();
					}
					this.hiddenLayer = [];
					for(var i = 0; i < numHiddenNodes * 2; i++) {
						this.hiddenLayer[i] = Math.random();
					}
				}

				this.fitness = 0;
				this.car = new Car();
				resetSimulation(this);
				Matter.Events.on(engine, 'afterUpdate', function(event) {
					var engine = event.source;
					this.car.update();
				}.bind(this));
				// this.fitness = this.calculateFitness();
			};

			var Car = function(width, height) {
				if(!width) {
					width = 30;
				}
				if(!height) {
					height = 60;
				}

				var chassis = Matter.Bodies.rectangle(0, 0, width, height);
				var parts = [chassis];
				var wheelOptions = {density: 0};
				parts.push(Matter.Bodies.rectangle(-width / 2, -(height - 20) / 2, 5, 10, wheelOptions));
				parts.push(Matter.Bodies.rectangle(width / 2, -(height - 20) / 2, 5, 10, wheelOptions));
				parts.push(Matter.Bodies.rectangle(width / 2, (height - 20) / 2, 5, 10, wheelOptions));
				parts.push(Matter.Bodies.rectangle(-width / 2, (height - 20) / 2, 5, 10, wheelOptions));


				this.body = Matter.Body.create({parts: parts});
				Matter.Body.scale(this.body, 4, 4);

				this.steer = 0;
				this.localVelocity = {x: 0, y: 0};
				this.engineForce = 0;
				this.brakingForce = 0;
			};

			Car.prototype.setPosition = function(x, y) {
				Matter.Body.setPosition(this.body, {x: x, y: y});
			};

			Car.prototype.update = function() {
				var left = inputs['key37'] ? -0.75 : 0;
				var right = inputs['key39'] ? 0.75 : 0;
				this.steer = this.steer * 0.9 + (left + right) * 0.1;
				Matter.Body.setAngle(this.body.parts[2], this.steer);
				Matter.Body.setAngle(this.body.parts[3], this.steer);

				this.localVelocity = Matter.Vector.rotate(this.body.velocity, this.body.angle);
			};

			function resetSimulation(individual) {
				Matter.Events.off(engine);
				Matter.World.clear(engine.world);
				Matter.Engine.clear(engine);

				var edges = [];
				edges.push(Matter.Bodies.rectangle(-10, 300, 20, 640, {isStatic: true}));
				edges.push(Matter.Bodies.rectangle(400, -10, 840, 20, {isStatic: true}));
				edges.push(Matter.Bodies.rectangle(810, 300, 20, 640, {isStatic: true}));
				edges.push(Matter.Bodies.rectangle(400, 610, 840, 20, {isStatic: true}));
				Matter.World.add(engine.world, edges);

				if(individual) {
					individual.car.setPosition(400, 300);
					Matter.World.add(engine.world, individual.car.body);
				}

				var mouse = Matter.Mouse.create(render.canvas),
				mouseConstraint = Matter.MouseConstraint.create(engine, {
					mouse: mouse,
					constraint: {
						stiffness: 0.2
					}
				});

				Matter.World.add(engine.world, mouseConstraint);
				render.mouse = mouse;
			};

			function tick(time) {
				Matter.Engine.update(engine, 1000 / 60);
				Matter.Render.world(render);

				document.querySelector('#car').innerHTML = "steer: " + a.car.steer.toFixed(2) +
														   " | localVelocity: {x: " + a.car.localVelocity.x.toFixed(2) + ", y: " + a.car.localVelocity.y.toFixed(2) + "}" +
														   " | engine: " + a.car.engineForce +
														   " | braking: " + a.car.brakingForce;
				document.querySelector('#inputs').innerHTML = JSON.stringify(inputs);

				tickId = requestAnimFrame(tick);
			};

			function iterate() {
				var datalen = data.length;

				data = data.sort(function(a, b) {
					return b.fitness - a.fitness;
				});

				data[0].draw(ctx, canvas.width / width);
				mutationAmount = 0.1 / Math.pow(data[0].fitness, 2);

				var breeders = data.slice(0, Math.max(2, ~~(datalen * 0.15)));
				data = [];
				for(var i = data.length; i < datalen; i++) {
					breeders = shuffle(breeders);
					data.push(new Individual(breeders[0], breeders[1]));
				}

				tickId = requestAnimFrame(iterate);
			}

			function start() {
				if(!tickId) {
					iterate();
				}
			}

			function reset() {
				cancelAnimFrame(tickId);
				tickId = false;

				data = [];
				for(var i = 0; i < 20; i++) {
					data.push(new Individual());
				}
			}

			var a = new Individual();
			tick();

			document.addEventListener('keydown', function(e) {
				inputs['key' + e.keyCode] = true;
			});

			document.addEventListener('keyup', function(e) {
				inputs['key' + e.keyCode] = false;
			});
		</script>
	</body>
</html>
