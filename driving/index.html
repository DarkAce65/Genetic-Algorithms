<!DOCTYPE html>
<html>
	<head>
		<title>Driving Simulation</title>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script type="text/javascript" src="node_modules/p2/build/p2.js"></script>
		<style type="text/css">
			html, body {
				margin: 0;
				padding: 0;
			}

			body {
				height: 100%;
				color: white;
				background-color: #121212;
				text-align: center;
			}

			#canvas {
				border: 1px solid white;
			}
		</style>
	</head>
	<body>
		<div style="margin: 20px;">
			<canvas id="canvas"></canvas>
		</div>
		<div id="genetic" style="font-family: monospace;"></div>
		<div id="net" style="font-family: monospace;"></div>
		<script type="text/javascript">
			'use strict';

			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			window.cancelAnimFrame =
				window.cancelAnimationFrame ||
				window.mozCancelAnimationFrame;

			function shuffle(array) { // Fisherâ€“Yates Shuffle
				var m = array.length, t, i;
				while(m) {
					i = Math.floor(Math.random() * m--);
					t = array[m];
					array[m] = array[i];
					array[i] = t;
				}
				return array;
			}

			var inputs = {
				'32': 0,
				'37': 0,
				'38': 0,
				'39': 0,
				'40': 0
			};

			var tickId = false;
			var numInputNodes = 3;
			var numHiddenNodes = 5;
			var numOutputNodes = 3;
			var mutationChance = 0.1;
			var mutationAmount = 0.1;
			var speedAvgWindow = 50;

			var data = [];
			var generation = 0;
			var genome = 0;
			var currentIndividual;
			var bestFitness = 0;

			var width = 800;
			var height = 600;
			var canvas = document.getElementById('canvas');
			canvas.width = width;
			canvas.height = height;
			var ctx = canvas.getContext('2d');
		    ctx.scale(1, -1);
		    ctx.translate(0, -height);

			var world = new p2.World({gravity: [0, 0]});
			var wallColGroup = 2;
			var walls = [];

			var Individual = function(p1, p2) {
				this.inputLayerWeights = [];
				this.hiddenLayerWeights = [];

				if(p1 && p2) {
					for(var i = 0; i < numInputNodes * numHiddenNodes; i++) {
						if(Math.random() < 0.5) {
							this.inputLayerWeights.push(p1.inputLayerWeights[i]);
						}
						else {
							this.inputLayerWeights.push(p2.inputLayerWeights[i]);
						}

						if(Math.random() < mutationChance) {
							var v = this.inputLayerWeights[i];
							v += (Math.random() * 2 - 1) * mutationAmount;
							v = Math.max(-1, Math.min(1, v));
							this.inputLayerWeights[i] = v;
						}
					}
					for(var i = 0; i < numHiddenNodes * numOutputNodes; i++) {
						if(Math.random() < 0.5) {
							this.hiddenLayerWeights.push(p1.hiddenLayerWeights[i]);
						}
						else {
							this.hiddenLayerWeights.push(p2.hiddenLayerWeights[i]);
						}

						if(Math.random() < mutationChance) {
							var v = this.inputLayerWeights[i];
							v += (Math.random() * 2 - 1) * mutationAmount;
							v = Math.max(-1, Math.min(1, v));
							this.inputLayerWeights[i] = v;
						}
					}
				}
				else {
					for(var i = 0; i < numInputNodes * numHiddenNodes; i++) {
						this.inputLayerWeights.push(Math.random() * 2 - 1);
					}
					for(var i = 0; i < numHiddenNodes * numOutputNodes; i++) {
						this.hiddenLayerWeights.push(Math.random() * 2 - 1);
					}
				}

				this.prevFitness = 0;
				this.fitness = 0;
				this.finished = false;
				this.car = new Car(20, 40);
			};

			Individual.prototype.setSimulation = function() {
				world.clear();
				world.gravity = [0, 0];

				world.on('beginContact', function(event) {
					currentIndividual.finished = true;
					bestFitness = Math.max(bestFitness, currentIndividual.fitness);
				});

				addTrack();

				this.prevFitness = 0;
				this.fitness = 0;
				this.finished = false;

				this.car = new Car(20, 40);
				world.addBody(this.car.chassis.body);
				this.car.tdv.addToWorld(world);

				currentIndividual = this;
			};

			Individual.prototype.update = function(dt) {
				this.car.update();

				if(this.car.speeds.length == speedAvgWindow && this.car.avgSpeed < 1) {
					this.finished = true;
					bestFitness = Math.max(bestFitness, this.fitness);
				}

				var inputLayer = this.car.getDistances();
				var hiddenLayer = [0, 0, 0, 0, 0];
				var outputLayer = [0, 0, 0];

				for(var i = 0; i < numHiddenNodes; i++) {
					for(var j = 0; j < numInputNodes; j++) {
						hiddenLayer[i] += inputLayer[j] * this.inputLayerWeights[i * numInputNodes + j];
					}
				}

				for(var i = 0; i < numOutputNodes; i++) {
					for(var j = 0; j < numHiddenNodes; j++) {
						outputLayer[i] += hiddenLayer[j] * this.hiddenLayerWeights[i * numHiddenNodes + j];
					}
				}

				for(var i = 0; i < numOutputNodes; i++) {
					outputLayer[i] = Math.min(Math.max(0, outputLayer[i]), 1);
				}
				var net = '';
				for(var i = 0; i < numInputNodes; i++) {
					net += inputLayer[i].toFixed(2);
					net += ',';
				}
				net += '<br>';
				for(var i = 0; i < numHiddenNodes; i++) {
					net += hiddenLayer[i].toFixed(2);
					net += ',';
				}
				net += '<br>';
				for(var i = 0; i < numOutputNodes; i++) {
					net += outputLayer[i].toFixed(2);
					net += ',';
				}

				this.car.steer = outputLayer[0];
				this.car.throttle = outputLayer[1];
				this.car.brake = outputLayer[2];
				this.prevFitness = this.fitness;
				this.fitness += this.car.avgSpeed * dt / 1000;
				document.querySelector('#net').innerHTML = net + '<br>speed: ' + this.car.avgSpeed.toFixed(2) + ', fitness: ' + this.fitness.toFixed(2) + '<br>best fitness: ' + bestFitness.toFixed(2);
			};

			var Car = function(bodyWidth, bodyHeight) {
				var chassisBody = new p2.Body({position: [400, 300], mass: 1});
				var boxShape = new p2.Box({
					width: bodyWidth,
					height: bodyHeight,
					collisionMask: wallColGroup
				});
				chassisBody.addShape(boxShape);

				var vehicle = new p2.TopDownVehicle(chassisBody);
				var flWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2,  bodyHeight / 2]});
				var frWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2,  bodyHeight / 2]});
				var blWheel = vehicle.addWheel({localPosition: [-bodyWidth / 2, -bodyHeight / 2]});
				var brWheel = vehicle.addWheel({localPosition: [ bodyWidth / 2, -bodyHeight / 2]});
				flWheel.setSideFriction(400);
				frWheel.setSideFriction(400);
				blWheel.setSideFriction(300);
				brWheel.setSideFriction(300);

				flWheel.setBrakeForce(20);
				frWheel.setBrakeForce(20);

				var lSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});
				lSensor.update();
				var fSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});
				var rSensor = new p2.Ray({
					mode: p2.Ray.CLOSEST,
					collisionMask: wallColGroup
				});

				this.tdv = vehicle;
				this.chassis = {
					body: chassisBody,
					box: boxShape
				};
				this.wheels = [flWheel, frWheel, blWheel, brWheel];
				this.lSensor = lSensor;
				this.fSensor = fSensor;
				this.rSensor = rSensor;

				this.speeds = [];
				this.avgSpeed = 0;
				this.steer = 0.5;
				this.throttle = 0;
				this.brake = 0;
			};

			Car.prototype.getDistances = function() {
				var distances = [1, 1, 1];
				var result = new p2.RaycastResult();
				world.raycast(result, this.lSensor);
				drawRayResult(result, this.lSensor);
				if(result.hasHit()) {
					distances[0] = result.getHitDistance(this.lSensor) / 75;
				}
				result.reset();
				world.raycast(result, this.fSensor);
				drawRayResult(result, this.fSensor);
				if(result.hasHit()) {
					distances[1] = result.getHitDistance(this.fSensor) / 75;
				}
				result.reset();
				world.raycast(result, this.rSensor);
				drawRayResult(result, this.rSensor);
				if(result.hasHit()) {
					distances[2] = result.getHitDistance(this.rSensor) / 75;
				}

				return distances;
			};

			Car.prototype.update = function() {
				this.speeds.push((this.wheels[2].getSpeed() + this.wheels[3].getSpeed()) / 2);
				if(this.speeds.length > speedAvgWindow) {
					this.speeds.shift();
				}

				var sum = 0;
				for(var i = 0; i < this.speeds.length; i++) {
					sum += this.speeds[i];
				}
				this.avgSpeed = sum / this.speeds.length;

				var steerValue = 0.63 * -(this.steer * 2 - 1);
				var engineForce = 150 * this.throttle;
				var brakeForce = 150 * this.brake;

				this.wheels[0].steerValue = steerValue;
				this.wheels[1].steerValue = steerValue;

				this.wheels[2].engineForce = engineForce;
				this.wheels[3].engineForce = engineForce;

				this.wheels[2].setBrakeForce(brakeForce);
				this.wheels[3].setBrakeForce(brakeForce);

				var w = this.chassis.box.width * 9 / 10;
				var h = this.chassis.box.height * 9 / 10;
				var sensorPositions = [];
				sensorPositions.push([-w / 2, h / 2]);
				sensorPositions.push([     0, h / 2]);
				sensorPositions.push([ w / 2, h / 2]);
				sensorPositions.push([-w / 2 - 45, h / 2 + 60]);
				sensorPositions.push([     0     , h / 2 + 75]);
				sensorPositions.push([ w / 2 + 45, h / 2 + 60]);
				for(var i = 0; i < sensorPositions.length; i++) {
					p2.vec2.rotate(sensorPositions[i], sensorPositions[i], this.chassis.body.angle);
					p2.vec2.add(sensorPositions[i], sensorPositions[i], this.chassis.body.position);
				}

				this.lSensor.from = sensorPositions[0];
				this.lSensor.to = sensorPositions[3];
				this.fSensor.from = sensorPositions[1];
				this.fSensor.to = sensorPositions[4];
				this.rSensor.from = sensorPositions[2];
				this.rSensor.to = sensorPositions[5];

				this.lSensor.update();
				this.fSensor.update();
				this.rSensor.update();
			};

			Car.prototype.draw = function() {
				ctx.strokeStyle = 'white';
		        var x = this.chassis.body.position[0];
		        var y = this.chassis.body.position[1];
				var w = this.chassis.box.width;
				var h = this.chassis.box.height;

		        ctx.save();
		        ctx.translate(x, y);
		        ctx.rotate(this.chassis.body.angle);

				ctx.translate(-w / 2, -h / 2);
				ctx.beginPath();
				ctx.rect(0, 0, w, h);
				ctx.translate(w / 2, h / 2);

				var wheelWidth = w / 6;
				var wheelHeight = h / 6;
				for(var i = 0; i < this.wheels.length; i++) {
					var w = this.wheels[i];
					var x = w.localPosition[0];
					var y = Math.sign(w.localPosition[1]) * (Math.abs(w.localPosition[1]) - wheelHeight);

					ctx.save();
					ctx.translate(x, y);
					if(i < 2) {
						ctx.rotate(0.63 * -(this.steer * 2 - 1));
					}
			        ctx.translate(-wheelWidth / 2, -wheelHeight / 2);

					ctx.rect(0, 0, wheelWidth, wheelHeight);
			        ctx.restore();
				}

				ctx.stroke();
		        ctx.restore();
			};

			function buildTrack() {
				for(var i = 0; i < 20; i++) {
					var wall = new p2.Body({
						position: [width * Math.random(), height * Math.random()],
						angle: 2 * Math.PI * Math.random()
					});
					wall.addShape(new p2.Box({
						width: 80 * Math.random() + 30,
						height: 80 * Math.random() + 30,
						collisionGroup: wallColGroup
					}));
					walls[i] = wall;
				}

				var top = new p2.Body({position: [width / 2, 0]});
				top.addShape(new p2.Box({
					width: width,
					height: 20,
					collisionGroup: wallColGroup
				}));
				walls.push(top);
				var bottom = new p2.Body({position: [width / 2, height]});
				bottom.addShape(new p2.Box({
					width: width,
					height: 20,
					collisionGroup: wallColGroup
				}));
				walls.push(bottom);
				var left = new p2.Body({position: [0, height / 2]});
				left.addShape(new p2.Box({
					width: 20,
					height: height,
					collisionGroup: wallColGroup
				}));
				walls.push(left);
				var right = new p2.Body({position: [width, height / 2]});
				right.addShape(new p2.Box({
					width: 20,
					height: height,
					collisionGroup: wallColGroup
				}));
				walls.push(right);
			}

			function addTrack() {
				for(var i = 0; i < walls.length; i++) {
					world.addBody(walls[i]);
				}
			}

			function drawWall(wall) {
				ctx.strokeStyle = 'white';
				ctx.beginPath();
				ctx.save();
				ctx.translate(wall.position[0], wall.position[1]);
				ctx.rotate(wall.angle);
				ctx.rect(-wall.shapes[0].width / 2, -wall.shapes[0].height / 2, wall.shapes[0].width, wall.shapes[0].height);
				ctx.stroke();
				ctx.restore();
			}

			function drawRayResult(result, ray){
				ctx.strokeStyle = 'skyblue';
				ctx.beginPath();
				ctx.moveTo(ray.from[0], ray.from[1]);
				ctx.lineTo(ray.to[0], ray.to[1]);
				ctx.stroke();

				ctx.strokeStyle = 'red';
				var hitPoint = p2.vec2.create();
				result.getHitPoint(hitPoint, ray);

				if(result.hasHit()) {
					ctx.beginPath();
					ctx.arc(hitPoint[0], hitPoint[1], 5, 0, 2 * Math.PI);
					ctx.stroke();
				}

				ctx.beginPath();
				ctx.moveTo(hitPoint[0], hitPoint[1]);
				ctx.lineTo(hitPoint[0] + result.normal[0] * 10, hitPoint[1] + result.normal[1] * 10);
				ctx.stroke();
			}

			function makeNewPopulation() {
				genome = 0;
				if(generation == 0) {
					data = [];
					for(var i = 0; i < 20; i++) {
						data.push(new Individual());
					}
				}
				else {
					var datalen = data.length;
					data = data.sort(function(a, b) {
						return b.fitness - a.fitness;
					});

					var breeders = data.slice(0, Math.max(2, ~~(datalen * 0.15)));
					data = [breeders[0]];
					for(var i = data.length; i < datalen - 1; i++) {
						breeders = shuffle(breeders);
						data.push(new Individual(breeders[0], breeders[1]));
					}
					data.push(new Individual());
				}
			}

			var lastTime;
			function tick(time) {
				var dt = lastTime ? time - lastTime : 0;
				world.step(1 / 60, dt / 1000, 10);
				ctx.clearRect(0, 0, width, height);

				for(var i = 0; i < walls.length; i++) {
					drawWall(walls[i]);
				}

				if(currentIndividual) {
					currentIndividual.update(dt);
					currentIndividual.car.draw();

					if(currentIndividual.finished) {
						genome++;
						if(genome >= data.length) {
							generation++;
							makeNewPopulation();
						}

						currentIndividual = data[genome];
						currentIndividual.setSimulation();
						document.querySelector('#genetic').innerHTML = 'Generation: ' + generation + ', Genome: ' + genome;
					}
				}

				lastTime = time;
				tickId = requestAnimFrame(tick);
			}

			function start() {
				if(!tickId) {
					currentIndividual = data[0];
					currentIndividual.setSimulation();
					document.querySelector('#genetic').innerHTML = 'Generation: ' + generation + ', Genome: ' + genome;
					tick();
				}
			}

			function reset() {
				buildTrack();

				cancelAnimFrame(tickId);
				tickId = false;

				bestFitness = 0;
				generation = 0;
				genome = 0;
				makeNewPopulation();
			}

			reset();
		</script>
	</body>
</html>
